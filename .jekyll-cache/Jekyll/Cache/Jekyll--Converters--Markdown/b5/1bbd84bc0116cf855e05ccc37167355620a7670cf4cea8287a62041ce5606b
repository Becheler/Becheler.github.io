I"ß<p>The <strong>Single Responsibility Principle</strong> (the <strong>S</strong> of the 5 <a href="/how-to-write-solid-code/">5 S.O.L.I.D. principles</a>) states that <em>each class should do just one thing, but do it well.</em>
Why so? Well, think about the way our body organs work together: do we digest stuff
at the exact same place we process cognition? Of course not! We evolved <strong>differentiated organs</strong> that are specialized for a
<strong>very small subset of related functions</strong>.
For example, the main responsibility of <em>eyes</em> is to perceive <em>light</em>.
The <em>liver</em> has been blessed with the <em>detoxification</em> responsibility.
Remark how <strong>clear structure</strong> of human body organs makes <strong>surgeries surprisingly easy</strong> - or at least doable.
Surgeons can remove a diseased liver
and replace it with a healthy liver in 6 hours! Can you replace that old, slow and buggy
code of yours with a healthier version in the same amount of time?</p>

<p><img src="/assets/img/doodles/code_surgery_front_desk_SRP.jpg" alt="Single Responsibility Principle: make code surgery possible" /></p>

<p>Objects in our code should ideally work in the same way organs do in a healthy body.
Big organs with clearly separated functions, all in constant interaction. They produce, exchange,
communicate, sometimes fail, but their <strong>structure</strong> is still <strong>striking and robust</strong>.</p>

<p>Of course, it happens often that to perform one task very well one has to do a lot
behind the curtain: take for example the <strong>amygdala</strong>, this structure near the base of your brain.
To do <em>fast decision-making</em> right,
it needs to process both <em>memories and emotional responses</em> so it can associate adverse
experiences with negative feelings. Next time you encounter a situation that the amygdala
considers as vaguely similar to a bad memory (letâ€™s say encounter with a tiger) it will fire
the right decision in no time (that is, <del>running of course</del> getting closer to properly document
their stripe pattern: <strong>youâ€™re a biologist after all</strong>).</p>

<p><em>Complexity is structured complications</em>.</p>

<p><img src="/assets/img/doodles/scalpel.jpg" alt="Single Responsibility Principle: make code surgery easy" /></p>

<p>If you want to see programmatic organs emerge from
the primordial soup of your code, try to follow these steps:</p>

<ol>
  <li>
    <p><strong>Think bigger! Think smaller! Think at the right level!</strong></p>

    <p>Identify the responsibility of the piece of code youâ€™re working with: what is it supposed to do <strong>conceptually</strong>?</p>

    <p>For example: <em>I want my class to read a tiger strip from a picture and match it to the tiger ID</em>.</p>

    <p>Donâ€™t think about <em>lists</em>, <em>pointers</em> or <em>arrays</em>. These are often <strong>implementation details</strong> that should
be hidden behind a neat class interface. Find the right level of abstraction youâ€™re working with by naming
a <strong>tiger strip</strong> a <code class="language-plaintext highlighter-rouge">tiger_strip</code> in your code, not a <code class="language-plaintext highlighter-rouge">boost::matrix&lt;double&gt;</code>!</p>
  </li>
  <li>
    <p><strong>Code surgery is easier when you operate on clearly delimited programmatic organs.</strong></p>

    <p>Establish a clear separation between what is the responsibility of one class and another.</p>

    <p>Sometimes things are more easily said than done. When you look into the details, maybe you will
discover that <em>matching a strip to a number</em> actually involves some pretty badass
pattern recognition stuff that should become the responsibility of
another class!</p>
  </li>
  <li>
    <p><strong>A big bad code is better than no code at all</strong>.</p>

    <p>Begin somewhere.</p>

    <p>Even if you feel bad, or even if you donâ€™t know <em>yet</em> what your class is supposed to do.
As long as you are intentional with the <strong>S.R.P.</strong>, itâ€™s fine! Even if you feel bad
writing that awful blob of code at least you know when, where
and why you violated the <em>S.R.P</em>, what are the possible consequences and what would be the solutions.</p>

    <p>But as you progress, donâ€™t hesitate to export responsibilities when your class becomes too big:
a class that does too many things at the same time is impossible to test or debug.</p>
  </li>
  <li>
    <p><strong>Find the balance between the mammoth and the atom</strong>.</p>

    <p>You will overuse the <strong>S.R.P</strong> it. Donâ€™t. But you will. Thatâ€™s how you learn!</p>

    <p>When you will have exported aaaaall
responsibilities of this big mammoth class to hundreds of smaller and smaller other classes, you will be left
with a scrawny class which only responsibility is to represent â€¦ a boolean.
Thatâ€™s useless, one class already does that perfectly: the boolean class.
But at least you will be able to recognize the early stages of misusing the <strong>Single Responsibility Principle</strong>!</p>

    <p>And thatâ€™s fine - and fun! LÃ©onin is still figuring this out!</p>
  </li>
</ol>

<p><img src="/assets/img/doodles/SRP_application.jpg" alt="LÃ©onin trying his best to apply the Single Responsibility Principle" /></p>
:ET