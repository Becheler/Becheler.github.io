<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Quetzal Tutorials | Arnaud Becheler</title>
<meta property="og:title" content="Quetzal Tutorials" />
<meta name="author" content="Arnaud Becheler" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Defining niche functions" />
<meta property="og:description" content="Defining niche functions" />
<link rel="canonical" href="http://localhost:4000/pages/tuto_niche.html" />
<meta property="og:url" content="http://localhost:4000/pages/tuto_niche.html" />
<meta property="og:site_name" content="Arnaud Becheler" />
<script type="application/ld+json">
{"sameAs":null,"datePublished":null,"description":"Defining niche functions","@type":"WebPage","image":null,"mainEntityOfPage":null,"url":"http://localhost:4000/pages/tuto_niche.html","name":null,"publisher":null,"author":{"@type":"Person","name":"Arnaud Becheler"},"headline":"Quetzal Tutorials","dateModified":null,"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="description" content="Defining niche functions"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/assets/css/style.css?v=">


  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [ ['$','$'], ['\(', '\)'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true,
    }
  });
</script>
<script type="text/javascript"
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </head>
  <body>

    <section class="page-header">
  <h1 class="project-name">QUETZAL</h1>
  <h2 class="project-tagline">The Coalescence Template Library</h2>
  <a href="../pages/quetzal.html" class="btn">Home</a>
  <a href="../pages/getting_started.html" class="btn">Getting Started</a>
  <a href="../pages/tutorials.html" class="btn">Tutorials</a>
  <a href="https://github.com/Becheler/quetzal" class="btn">GitHub</a>
  <a href="../quetzalAPI/html/index.html" class="btn">Devs Doc</a>
  <a href="../index.html" class="btn">Maintainer</a>
</section>


    <section class="main-content">
      <h1 id="defining-niche-functions-in-the-simulation-model">Defining niche functions in the simulation model</h1>

<h2 id="introduction">Introduction</h2>

<p>By <em>niche functions</em>, we mean any model quantity that is linked to environmental
quantities.</p>

<p>For example the following function is what we would call a niche function: the growth rate
is a function of the temperature.</p>

<p><img src="http://localhost:4000/pictures/niche.png" alt="niche function" /></p>

<p>Usually in demogenetic models, the “true” niche functions are not precisely known,
so their forms have to be inferred. In the previous picture, we would typically try to estimate
the parameters $T_{opt}$, $T_{min}$ and $T_{max}$.</p>

<p>If you are reading this tutorial, it means that you are
probably interested in simulation-based inference: in such frameworks a huge amount of simulations is needed to explore the parameters
space. Quetzal allows to explore the parameter space of the niche functions with
a priori better efficiency than achieved by previous simulation resources.</p>

<blockquote>
  <p>Why ?</p>
</blockquote>

<p>Typically, an ABC analysis would require:</p>
<ul>
  <li>the raw geographic dataset to be read and tranformed using an external software with a
given set of parameters</li>
  <li>The tranformed data to be written in memory</li>
  <li>The transformed data to be read by the demogenetic program to run a simulation.</li>
</ul>

<p>And this <em>read-write-read</em> cycle would repeat <em>millions of times</em> as the parameters are resampled.</p>

<p>We advocate that it is a <em>costly way to compute things</em>. Instead, we prefer to
integrate the model choice into the demogenetic simulation program, so the data transformations
are computed <em>on the fly</em> rather than written in memory. Plus, it fosters scientific reproducibility.</p>

<p>As there are a open-ended number of possible models, and that their relevancy is
very specific to the question at hand, we choose to
leave the user free to define its own niche functions, and we give him the right
tools to do so.</p>

<h2 id="an-example-the-logistic-growth">An example: the logistic growth</h2>

<p>For example, let’s consider the typical logistic function that is used in the literature
to represent the local growth process, and let’s couple the growth rate and the carrying
capacity to the environmental heterogeneity.</p>

<p>The following picture illustrate a one-deme growing population size following a logistic growth,
with carrying capacity $K=500$, for different values of $r$:</p>

<p><img src="http://localhost:4000/pictures/logistic.png" alt="logistic growth" /></p>

<h3 id="mathematical-description">Mathematical description</h3>

<p>The number of descendants <script type="math/tex">\tilde{N}_{x}^{t}</script> in each deme can be sampled in a
distribution conditionally to a function of the the local density of parents,
for example</p>

<p><script type="math/tex">\tilde{N}_{x}^{t} \sim Poisson(g(x,t))</script>,</p>

<p>where $g$ can be for example a discrete version of the logistic growth:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{cc|ccc}
    g & : & \mathbb{X}\times \mathbb{N} & \mapsto & \mathbb{R}^{+} \\
      &   &          (x,t)               & \mapsto & \frac{N_{x}^{t}\times(1+r(x,t))}{1+\frac{r(x,t)\times N_{x}^{t}}{K(x,t)}}  ~. \\
\end{array} %]]></script>

<p>The $r$, respectively $k$, term is the growth rate, respectively the carrying capacity,
defined as a function of the environmental quantities with parameter $\theta$:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{ccccl}
K  & : & \mathbb{X}\times \mathbb{N} & \mapsto & \mathbb{R}^{+} \\
   &   &    (x,t)       & \mapsto & f_{K}^{\theta}(E(x,t))~, \\
\end{array} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{ccccl}
r  & : & \mathbb{X} & \mapsto & \mathbb{R} \\
   &   &    (x,t)       & \mapsto & f_{r}^{\theta}(E(x,t)) ~. \\
\end{array} %]]></script>

<p>We will show how to implement this model with toy functions.</p>

<h3 id="step-by-step-implementation">Step-by-step implementation</h3>

<h4 id="about-the-need-to-build-callable-expressions">About the need to build callable expressions</h4>

<p>So you learned in the <a href="tuto_geography">geography tutorial</a> how to retrieve the environmental functions:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s">"rain"</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s">"temperature"</span><span class="p">];</span>
</code></pre>
</div>
<blockquote>
  <p><strong>Note:</strong> Remember that you can call <code class="highlighter-rouge">f</code> and <code class="highlighter-rouge">g</code> with space and time arguments
by writing <code class="highlighter-rouge">f(x,t)</code> and <code class="highlighter-rouge">g(x,t)</code>.</p>
</blockquote>

<p>As the demographic expansion loop over space and time lays in the core of
complex simulation objects, you do not want to pass each of these values one-by-one
across the multiple layers of these objects: that would be very inefficient.</p>

<p>Instead, it is better to give to the simulator the expression that it will call.</p>

<p>You just need to code a function simulating the number of children in deme $x$
at time $t$. Any expression would work: the core algorithm will deal with it if it
has the right signature.</p>

<p>In the <a href="tuto_demography#implementing-a-local-growth-process">demography tutorial</a>,
you already learned how to build a very simple version of such expressions: it
was simply twice the number of parents. Let’s remember this simple example code:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// access to the demographic history database
</span><span class="k">auto</span> <span class="n">N</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cref</span><span class="p">(</span><span class="n">history</span><span class="p">.</span><span class="n">pop_sizes</span><span class="p">());</span>
<span class="c1">// capture N in a lambda expression
</span><span class="k">auto</span> <span class="n">growth</span> <span class="o">=</span> <span class="p">[</span><span class="n">N</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">coord_type</span> <span class="n">x</span><span class="p">,</span> <span class="n">time_type</span> <span class="n">t</span><span class="p">){</span> <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="p">;</span> <span class="p">};</span>
</code></pre>
</div>
<p>Here we will just learn how to define more complicated expressions that are
mathematical compositions of the environmental functions.</p>

<h3 id="composing-functions-of-space-and-time">Composing functions of space and time</h3>

<p>What you want to do is to build an expression that is the result of composing other
functions, and you expect this to be easy. You would actually expect to be able to write
something like:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s">"rain"</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s">"temperature"</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="n">g</span><span class="p">;</span> <span class="c1">// compilation error, undefined operator +
</span></code></pre>
</div>
<p>This code would not compile, as C++ does not natively know what adding $f$ and $g$ mean.</p>

<p>To enable the composition, you need to use the  <code class="highlighter-rouge">expressive</code> module.
This module is actually a library written by <a href="https://github.com/ambre-m">Ambre Marques</a>,
that allows to compose expressions at compile-time:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include "my_path/quetzal/expressive.h"
</span>
<span class="c1">// ... some code to build the environment object env
</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s">"rain"</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s">"temperature"</span><span class="p">];</span>

<span class="k">using</span> <span class="n">quetzal</span><span class="o">::</span><span class="n">expressive</span><span class="o">::</span><span class="n">use</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">use</span><span class="p">(</span><span class="n">g</span><span class="p">);</span> <span class="c1">// expressive automatically define the operator +
</span></code></pre>
</div>

<p>In this code, <code class="highlighter-rouge">h</code> is a new object. Its type is automatically built by <code class="highlighter-rouge">expressive</code>
and is unknown by the user: that is actually a good thing, as it can be very complicated.
More importantly, as the <code class="highlighter-rouge">h</code> object is cheap to copy, it can be passed around the
simulation context to the appropriate function where it will be called with spatio-temporal
coordinates:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// file main.cpp
</span><span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">use</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>

<span class="n">coord_type</span> <span class="n">x</span><span class="p">;</span>
<span class="n">time_type</span> <span class="n">t</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre>
</div>

<h3 id="composing-constant-functions">Composing constant functions</h3>

<p>In the same way can not expect the following line to work:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// // compilation error, undefined operator -
</span></code></pre>
</div>
<p>It is expected, as C++ does not natively know how to add an integer to a function.
So first you have to transform the number 4 to a constant function of space and time:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">using</span> <span class="n">quetzal</span><span class="o">::</span><span class="n">expressive</span><span class="o">::</span><span class="n">literal_factory</span><span class="p">;</span>
<span class="c1">// a small object able to produce callables:
</span><span class="n">literal_factory</span><span class="o">&lt;</span><span class="n">coord_type</span><span class="p">,</span> <span class="n">time_type</span><span class="o">&gt;</span> <span class="n">lit</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">h</span> <span class="o">-</span> <span class="n">lit</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// now it works
</span></code></pre>
</div>

<p>See ? You can actually freely compose any user-defined function.</p>

<h2 id="coupling-environment-logistic-growth-model-and-stochastic-sampling">Coupling environment, logistic growth model and stochastic sampling:</h2>

<p>Here are some code lines implementing a possible variant of the previously described
mathematical model where the number of children is a function of the number of
parents, of a constant growth rate, and where the carrying capacity is the mean
of the environmental variables:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// ... build the environment before this
</span>
<span class="k">using</span> <span class="n">quetzal</span><span class="o">::</span><span class="n">expressive</span><span class="o">::</span><span class="n">literal_factory</span><span class="p">;</span>
<span class="k">using</span> <span class="n">quetzal</span><span class="o">::</span><span class="n">expressive</span><span class="o">::</span><span class="n">use</span><span class="p">;</span>
<span class="n">literal_factory</span><span class="o">&lt;</span><span class="n">coord_type</span><span class="p">,</span> <span class="n">time_type</span><span class="o">&gt;</span> <span class="n">lit</span><span class="p">;</span>

<span class="c1">// constant growth rate
</span><span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

<span class="c1">// carrying capacity averging over rain and temperature
</span><span class="k">auto</span> <span class="n">K</span> <span class="o">=</span>  <span class="p">(</span> <span class="n">use</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">use</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="n">lit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">;</span>

<span class="c1">// retrieving the population size history
</span><span class="k">auto</span> <span class="n">N_cref</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cref</span><span class="p">(</span><span class="n">history</span><span class="p">.</span><span class="n">pop_sizes</span><span class="p">());</span>

<span class="c1">// Enabling its use with expressive:
</span><span class="k">auto</span> <span class="n">N_expr</span> <span class="o">=</span> <span class="n">use</span><span class="p">([</span><span class="n">N_cref</span><span class="p">](</span><span class="n">coord_type</span> <span class="n">x</span><span class="p">,</span> <span class="n">time_type</span> <span class="n">t</span><span class="p">){</span><span class="k">return</span> <span class="n">N_cref</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">);});</span>

<span class="c1">// Making the logistic growth expression:
</span><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">N_expr</span><span class="o">*</span><span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">/</span> <span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="p">((</span><span class="n">r</span> <span class="o">*</span> <span class="n">N_expr</span><span class="p">)</span><span class="o">/</span><span class="n">K</span><span class="p">));</span>

<span class="c1">// capturing g to build a sampling distribution
</span><span class="k">auto</span> <span class="n">sim_N_tilde</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">](</span><span class="n">generator_type</span><span class="o">&amp;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">coord_type</span> <span class="n">x</span><span class="p">,</span> <span class="n">time_type</span> <span class="n">t</span><span class="p">){</span>
  <span class="n">std</span><span class="o">::</span><span class="n">poisson_distribution</span><span class="o">&lt;</span><span class="n">history_type</span><span class="o">::</span><span class="n">N_type</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">poisson</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">poisson</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="p">};</span>

</code></pre>
</div>
<p>Then you can pass the <code class="highlighter-rouge">sim_N_tilde</code> expression to a demographic simulator.
 Remarkably, even if you change some lines you will always be able to pass
 this expression to the demographic simulator
 as long as you don’t modify its signature <code class="highlighter-rouge">(generator_type&amp; gen, coord_type x, time_type t)</code>.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Of course this niche model is not relevant: it’s a toy model. The main point is that it
is very easy for the user to modify it.</p>

<blockquote>
  <p>But what if $r$ is unknown and you want to estimate it ?</p>
</blockquote>

<p>The ABC tutorial will give you insights on how manipulating the parameters of the
niche functions in an ABC framework.</p>


      <footer class="site-footer">

  <div class="post-nav">
    <p>
      
    </p>
    <p>
      
    </p>
  </div>

  <span class="contact"><a href="mailto:Arnaud.Becheler@egce.cnrs-gif.fr">Contact me !</a> </span>
</footer>


    </section>

    
      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-106771332-1', 'auto');
  ga('send', 'pageview');

</script>

    

  </body>
</html>
